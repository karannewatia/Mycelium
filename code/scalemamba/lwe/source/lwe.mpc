execfile('/root/SCALE-MAMBA/Programs/ring/ring.mpc')
from Compiler import mpc_math


class LWE(object):

  # In order for decryption to work,
  #   N and m=2^lgM must be chosen appropriately.
  # Namely, if you wish to do t ciphertext additions
  #   and p is the size of the SCALE-MAMBA field, then need:
  #   t*2*N^2 < p / (2*m)
  def __init__(self, r, N, lgM, l, n, lgP):
    self.r = r  # Ring used
    self.N = N  # Half-width of binomial distributions
    # m = Modulus of ciphertext additions
    # Require p = 1 (mod 2m), and m to be a power of 2
    self.lgM = lgM
    self.m = 1 << lgM   # Plaintext modulus (size per element)
    self.l = l           # Plaintext length (number of elements)
    self.n = n
    self.lgP = lgP
    return

  def secret_key_gen(self):
    s = r.ringBinom(N)
    return s

  def calc_gs(self, g, s):
    gs = sint.Matrix(self.lgP, self.n)
    @for_range(self.lgP)
    def range_body(i):
      @for_range(self.n)
      def range_body_inner(j):
        gs[i][j] = g[i] * s[j]
    return gs

  def calc_u(self, lgN):
    @for_range(lgN)
    def _(k):
      u = cint.Matrix(self.lgP, self.n)
      @for_range(self.lgP)
      def range_body(i):
        tmp_u = r.ringRandClear()
        @for_range(self.n)
        def range_body_inner(j):
          u[i][j] = tmp_u[j]

      e = sint.Matrix(self.lgP, self.n)
      @for_range(self.lgP)
      def range_body(i):
        tmp_e = r.ringBinom(N)
        @for_range(self.n)
        def range_body_inner(j):
          e[i][j] = tmp_e[j]

  # Returns [a, b, s]
  # (b, a) is the public key, s is the secret key
  def key_gen(self):
    r = self.r
    N = self.N
    a = r.ringRandClear()
    s = r.ringBinom(N)
    e = r.ringBinom(N)
    a_neg = cint.Array(self.n)
    @for_range(self.n)
    def range_body(i):
      e[i] *= cint(self.m)
      a_neg[i] = -a[i]
    b = r.reveal(r.ringAdd(r.ringMulFast(a_neg, s), e))

    res = [b, a, s]
    return res

  #Calculate the binary representation of the given number
  def to_binary(self, number):
    res = cint.Array(self.lgP)
    @for_range(self.lgP)
    def range_body(i):
      res[i] = cint(0)
    num = cint.Array(1)
    num[0] = cint(number)
    if_then(num[0] < cint(0))
    num[0] = cint(-1) * num[0]
    end_if()

    @for_range(self.lgP-1, -1, -1)
    def range_body(i):
      if_then(num[0] > 1)
      res[i] = num[0] % 2
      num[0] = num[0] >> 1
      else_then()
      res[i] = num[0] % 2
      num[0] = 0
      end_if()

    return res

  #Returns g
  #calculate the decompose gadget g
  def decompose_gadget(self):
    g = cint.Array(self.lgP)
    @for_range(self.lgP)
    def range_body(i):
      g[i] = 2**i
    return g

  #Returns [v, u]
  #do key switching: generate key switching key k = (v|u)
  def key_switching(self, gs, s1, u_neg, e):
    r = self.r
    N = self.N

    #v = -u*s1 + g*s + e

    #u = cint.Matrix(self.lgP, self.n)
    #u_neg = cint.Matrix(self.lgP, self.n)
    #@for_range(self.lgP)
    #def range_body(i):
      #tmp_u = r.ringRandClear()
      #@for_range(self.n)
      #def range_body_inner(j):
        #u[i][j] = 0 #tmp_u[j]
        #u_neg[i][j] = 0 #-tmp_u[j]

    #e = sint.Matrix(self.lgP, self.n)
    #@for_range(self.lgP)
    #def range_body(i):
      #tmp_e = r.ringBinom(N)
      #@for_range(self.n)
      #def range_body_inner(j):
        #e[i][j] = 0 #tmp_e[j]

    #gs = sint.Matrix(self.lgP, self.n)
    #@for_range(self.lgP)
    #def range_body(i):
      #@for_range(self.n)
      #def range_body_inner(j):
        #gs[i][j] = g[i] * s[j]

    v = cint.Matrix(self.lgP, self.n)
    @for_range(self.lgP)
    def range_body(i):
      tmp_v = r.reveal(r.ringAdd(r.ringAdd(r.ringMulFast(u_neg[i], s1), gs[i]), e[i]))
      #tmp_v = r.reveal(r.ringAdd(r.ringAdd(s1, gs[i]), e[i]))
      @for_range(self.n)
      def range_body_inner(j):
        v[i][j] = tmp_v[j]

    res = [v, u_neg]
    return res

  #Generate the new ciphertext
  #Returns [c0_new, c1_new]
  def new_ciphertext(self, c0, c1, u, v):
    #(c0', c1') = (c0, 0) + g^-1 * K, where K = (u|v)

    g_inverse = cint.Matrix(self.n, self.lgP)
    c0_new = cint.Array(self.n)
    c1_new = cint.Array(self.n)
    @for_range(self.n)
    def range_body(i):
      c0_new[i] = cint(0)
      c1_new[i] = cint(0)
      tmp_binary = self.to_binary(c1[i])
      @for_range(self.lgP)
      def range_body_inner(j):
        if_then(c1[i] < cint(0))
        tmp_binary[j] = -tmp_binary[j]
        end_if()
        g_inverse[i][j] = tmp_binary[j]
    @for_range(self.lgP)
    def range_body(i):
      gt = cint.Array(self.n)
      @for_range(self.n)
      def range_body_inner(j):
        gt[j] = g_inverse[j][i]

      tmp0 = r.ringAddClear(r.ringMulFastClear(gt, u[i]), c0_new)
      tmp1 = r.ringAddClear(r.ringMulFastClear(gt, v[i]), c1_new)
      @for_range(self.n)
      def range_body_inner(j):
        c0_new[j] = tmp0[j]
        c1_new[j] = tmp1[j]

    c0_new = r.ringAdd(c0_new, c0)

    return [c0_new, c1_new]

  def rl_keys(self, s, a, g, e):
    r = self.r
    N = self.N

    #a = cint.Matrix(self.lgP, self.n)
    a_neg = cint.Matrix(self.lgP, self.n)

    @for_range(self.lgP)
    def range_body(i):
      #tmp_a = r.ringRandClear()
      @for_range(self.n)
      def range_body_inner(j):
        #a[i][j] = tmp_a[j]
        #a_neg[i][j] = -tmp_a[j]
        a_neg[i][j] = a[i][j]

    #e = sint.Matrix(self.lgP, self.n)
    #@for_range(self.lgP)
    #def range_body(i):
      #tmp_e = r.ringBinom(N)
      #@for_range(self.n)
      #def range_body_inner(j):
        #e[i][j] = tmp_e[j] * self.m

    s2 = r.ringMulFastSecret(s,s)

    gs = sint.Matrix(self.lgP, self.n)
    @for_range(self.lgP)
    def range_body(i):
      @for_range(self.n)
      def range_body_inner(j):
        gs[i][j] = g[i] * s2[j]

    b = cint.Matrix(self.lgP, self.n)
    @for_range(self.lgP)
    def range_body(i):
      tmp_b = r.reveal(r.ringAdd(r.ringAdd(r.ringMulFast(a_neg[i], s), e[i]), gs[i]))
      @for_range(self.n)
      def range_body_inner(j):
        b[i][j] = tmp_b[j]

    res = [b, a]
    return res

  # z is plaintext (array) of l elems each modulo m
  # returns ciphertext [u, v]
  def enc(self, b, a, z):
    r = self.r
    N = self.N
    m = self.m
    e0 = r.ringBinom(N)
    e1 = r.ringBinom(N)
    e2 = r.ringBinom(N)

    @for_range(self.n)
    def range_body(i):
      e1[i] *= cint(self.m)

    # u = a*e0 + m*e1 (mod q)
    u = r.ringMulFast(a, e0)
    u = r.ringAdd(u, e1)

    # v = b*e0 + m*e2 + z (mod p)
    mthP = cint(-1)/cint(m)

    zMthP = r.zero()

    for i in range(0, len(z)):
      zMthP[i] = z[i]

    @for_range(self.n)
    def range_body(i):
      e2[i] *= cint(self.m)

    v = r.ringMulFast(b, e0)
    v = r.ringAdd(v, e2)
    v = r.ringAdd(v, zMthP)

    res = [r.reveal(v), r.reveal(u)]
    return res


  def dec(self, v, u, s):
    r = self.r
    lgM = self.lgM
    m = 1 << lgM
    clearM = cint(m)
    zNoisy = r.ringAdd(v, r.ringMulFast(u, s))

    halfMthP = cint(-1)/(2*m)
    z = sint.Array(self.l)
    @for_range(self.l)
    def round(i):
      zNoisy[i] = zNoisy[i] + halfMthP
      zNoisy[i] = zNoisy[i] - halfMthP
      z[i] = zNoisy[i] % self.m

    return z

  def dec_mul(self, c0, c1, c2, s):
    r = self.r
    lgM = self.lgM
    m = 1 << lgM
    clearM = cint(m)
    s1 = r.ringMulFast(s,s)
    zNoisy = r.ringAdd(r.ringAdd(c0, r.ringMulFast(c1, s)), r.ringMulFast(c2, s1))

    halfMthP = cint(-1)/(2*m)
    z = sint.Array(self.l)
    @for_range(self.l)
    def round(i):
      zNoisy[i] = zNoisy[i] + halfMthP
      zNoisy[i] = zNoisy[i] - halfMthP
      z[i] = zNoisy[i] % self.m

    return z

  def add(self, u1, u2):
    r = self.r
    res = r.reveal(r.ringAdd(u1, u2))
    return res

  def mul(self, u1, u2):
    r = self.r
    res = r.reveal(r.ringMulFast(u1, u2))
    return res

  def exp_sample(self, mean):
    rand = sint.get_random_int(15)
    rand_fix = sfix.load_sint(rand)/32768
    log_r = mpc_math.log2_fx(rand_fix)
    return -mean*log_r

  def laplace(self, scale):
    e1 = self.exp_sample(scale)
    e2 = self.exp_sample(scale)
    return e1 - e2
